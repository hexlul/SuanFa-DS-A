//朴素的模式匹配算法BF算法：这是一种带回溯的匹配算法，简单效率低
//伪代码：1.在串S和串T中设置比较的下标i和j；
//        2.重复下述操作，直到S或T的所有字符都比较完毕：
//          2.1 如果S[i]等于T[j]，继续比较S和T的下一对字符；
//          2.2 否则将下标i和j回溯，准备下一趟比较；
//        3.如果T中所有字符都比较完，则匹配成功，返回匹配的开始位置；否则匹配失败，返回0；

int BF(char S[], char T[])
{
  i = 0; j = 0;
  while ((S[i]!='\0')&&(T[j]!='\0'))
  {
    if(S[i]==T[j])
    {
      i++; j++;
    }
    else
    {
      i = i-j+1;
      j = 0;
    }
  }
  if(T[j] == '\0') return (i-j+1);  //返回本趟匹配的开始位置（不是下标）
  else return 0;
}


//改进的模式匹配算法KMP法，其基本思想是主串不进行回溯
//
//
//
//
//
